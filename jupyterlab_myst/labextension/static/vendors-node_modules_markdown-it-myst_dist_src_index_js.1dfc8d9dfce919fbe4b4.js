(self["webpackChunkjupyterlab_myst"] = self["webpackChunkjupyterlab_myst"] || []).push([["vendors-node_modules_markdown-it-myst_dist_src_index_js"],{

/***/ "./node_modules/markdown-it-myst/dist/src/blocks.js":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/blocks.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.plugin = void 0;
const utils_1 = __webpack_require__(/*! markdown-it/lib/common/utils */ "./node_modules/markdown-it/lib/common/utils.js");
const state_1 = __webpack_require__(/*! ./state */ "./node_modules/markdown-it-myst/dist/src/state.js");
// % A comment
const COMMENT_PATTERN = /^%\s(.*)$/;
// (my_id)=
const TARGET_PATTERN = /^\(([a-zA-Z0-9|@<>*./_\-+:]{1,100})\)=\s*$/;
// +++ {"meta": "data"}
const BLOCK_BREAK_PATTERN = /^\+\+\+\s?(\{.*\})?$/;
function checkTarget(state, startLine, str, silent) {
    var _a;
    const match = TARGET_PATTERN.exec(str);
    if (match == null)
        return false;
    if (silent)
        return true;
    state.line = startLine + 1;
    const token = state.push('myst_target', '', 0);
    const id = (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : '';
    token.attrSet('id', id);
    token.map = [startLine, state.line];
    state_1.newTarget(state, id, state_1.TargetKind.ref);
    return true;
}
function checkComment(state, startLine, str, silent) {
    var _a;
    const match = COMMENT_PATTERN.exec(str);
    if (match == null)
        return false;
    if (silent)
        return true;
    state.line = startLine + 1;
    const token = state.push('myst_comment', '', 0);
    const comment = (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : '';
    token.attrSet('comment', comment);
    token.map = [startLine, state.line];
    return true;
}
function checkBlockBreak(state, startLine, str, silent) {
    var _a;
    const match = BLOCK_BREAK_PATTERN.exec(str);
    if (match == null)
        return false;
    if (silent)
        return true;
    state.line = startLine + 1;
    const token = state.push('myst_block_break', '', 0);
    const metadataString = (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : '{}';
    let metadata = {};
    try {
        metadata = JSON.parse(metadataString);
    }
    catch (error) {
        console.warn('Could not parse metadata for block break: ', metadataString);
    }
    token.meta = Object.assign(Object.assign({}, token.meta), { metadata });
    token.map = [startLine, state.line];
    return true;
}
const blockPlugins = [checkTarget, checkComment, checkBlockBreak];
function blocks(state, startLine, endLine, silent) {
    const pos = state.bMarks[startLine] + state.tShift[startLine];
    const maximum = state.eMarks[startLine];
    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4)
        return false;
    const str = state.src.slice(pos, maximum);
    return blockPlugins.reduce((complete, plug) => (complete || plug(state, startLine, str, silent)), false);
}
const renderTarget = (tokens, idx, opts, env) => {
    var _a, _b;
    const ref = (_a = tokens[idx].attrGet('id')) !== null && _a !== void 0 ? _a : '';
    const id = (_b = env.targets[ref]) === null || _b === void 0 ? void 0 : _b.id;
    // TODO: This should be better as part of the next element, and then hide this
    return (`<span id="${id}"></span>\n`);
};
const renderComment = (tokens, idx) => {
    var _a;
    const comment = (_a = tokens[idx].attrGet('comment')) !== null && _a !== void 0 ? _a : '';
    return (`<!-- ${utils_1.escapeHtml(comment)} -->\n`);
};
const renderBlockBreak = (tokens, idx) => {
    const { metadata } = tokens[idx].meta;
    console.log('Not sure what to do with metadata for block break:', metadata);
    return ('<!-- Block Break -->\n');
};
const addBlockTitles = (state) => {
    var _a;
    const { tokens } = state;
    const env = state_1.getStateEnv(state);
    for (let index = 0; index < tokens.length; index += 1) {
        const prev = tokens[index - 1];
        const token = tokens[index];
        const next = tokens[index + 1];
        if ((prev === null || prev === void 0 ? void 0 : prev.type) === 'myst_target' && token.type === 'heading_open') {
            const id = (_a = prev.attrGet('id')) !== null && _a !== void 0 ? _a : '';
            // TODO: Should likely have this actually be the rendered content?
            env.targets[id].title = utils_1.escapeHtml(next.content);
        }
    }
    return true;
};
const updateLinkHrefs = (state) => {
    const { tokens } = state;
    const env = state_1.getStateEnv(state);
    for (let index = 0; index < tokens.length; index += 1) {
        const token = tokens[index];
        if (token.type === 'inline' && token.children) {
            token.children.forEach((t) => {
                var _a, _b;
                if (t.type === 'link_open') {
                    const target = env.targets[(_a = t.attrGet('href')) !== null && _a !== void 0 ? _a : ''];
                    if (target) {
                        t.attrSet('title', (_b = target.title) !== null && _b !== void 0 ? _b : '');
                        t.attrSet('href', `#${target.id}`);
                    }
                }
            });
        }
    }
    return true;
};
function plugin(md) {
    md.block.ruler.before('hr', 'myst_blocks', blocks, { alt: ['paragraph', 'reference', 'blockquote', 'list', 'footnote_def'] });
    md.core.ruler.after('block', 'add_block_titles', addBlockTitles);
    md.core.ruler.after('inline', 'update_link_hrefs', updateLinkHrefs);
    md.renderer.rules.myst_target = renderTarget;
    md.renderer.rules.myst_comment = renderComment;
    md.renderer.rules.myst_block_break = renderBlockBreak;
}
exports.plugin = plugin;
//# sourceMappingURL=blocks.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/directives/admonition.js":
/*!*************************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/directives/admonition.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/markdown-it-myst/dist/src/directives/utils.js");
const admonitionTitles = {
    attention: 'Attention', caution: 'Caution', danger: 'Danger', error: 'Error', important: 'Important', hint: 'Hint', note: 'Note', seealso: 'See Also', tip: 'Tip', warning: 'Warning',
};
const DEFAULT_ADMONITION_CLASS = 'note';
const createAdmonition = (kind) => {
    const className = kind === 'admonition' ? DEFAULT_ADMONITION_CLASS : kind;
    return {
        token: kind,
        getArguments: (info) => {
            const content = kind === 'admonition' ? '' : info;
            const title = kind === 'admonition' ? info : admonitionTitles[kind];
            const args = { title };
            return { args, content };
        },
        getOptions: (data) => {
            const { class: overrideClass } = data, rest = __rest(data, ["class"]);
            utils_1.unusedOptionsWarning(kind, rest);
            return { class: overrideClass };
        },
        renderer: (args, opts) => {
            const { title } = args;
            const { class: overrideClass } = opts;
            return [
                'aside', { class: ['callout', overrideClass || className] },
                ['header', { children: title }],
                0,
            ];
        },
    };
};
const admonitions = {
    admonition: createAdmonition('admonition'),
    callout: createAdmonition('admonition'),
    // All other admonitions
    attention: createAdmonition('attention'),
    caution: createAdmonition('caution'),
    danger: createAdmonition('danger'),
    error: createAdmonition('error'),
    important: createAdmonition('important'),
    hint: createAdmonition('hint'),
    note: createAdmonition('note'),
    seealso: createAdmonition('seealso'),
    tip: createAdmonition('tip'),
    warning: createAdmonition('warning'),
};
exports.default = admonitions;
//# sourceMappingURL=admonition.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/directives/figure.js":
/*!*********************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/directives/figure.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const state_1 = __webpack_require__(/*! ../state */ "./node_modules/markdown-it-myst/dist/src/state.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/markdown-it-myst/dist/src/directives/utils.js");
const figure = {
    figure: {
        token: 'figure',
        numbered: state_1.TargetKind.figure,
        autoNumber: true,
        getArguments: (info) => {
            const args = { src: info.trim() };
            return { args, content: '' };
        },
        getOptions: (data) => {
            const { name } = data, rest = __rest(data, ["name"]);
            utils_1.unusedOptionsWarning('figure', rest);
            return { name };
        },
        renderer: (args, opts, target) => {
            const { src } = args;
            const { id, number } = target !== null && target !== void 0 ? target : {};
            return [
                'figure', { id, class: 'numbered' },
                ['img', { src }],
                ['figcaption', { number }, 0],
            ];
        },
    },
};
exports.default = figure;
//# sourceMappingURL=figure.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/directives/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/directives/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.plugin = exports.directives = void 0;
const admonition_1 = __importDefault(__webpack_require__(/*! ./admonition */ "./node_modules/markdown-it-myst/dist/src/directives/admonition.js"));
const figure_1 = __importDefault(__webpack_require__(/*! ./figure */ "./node_modules/markdown-it-myst/dist/src/directives/figure.js"));
const math_1 = __importDefault(__webpack_require__(/*! ./math */ "./node_modules/markdown-it-myst/dist/src/directives/math.js"));
exports.directives = Object.assign(Object.assign(Object.assign({}, admonition_1.default), figure_1.default), math_1.default);
var plugin_1 = __webpack_require__(/*! ./plugin */ "./node_modules/markdown-it-myst/dist/src/directives/plugin.js");
Object.defineProperty(exports, "plugin", ({ enumerable: true, get: function () { return plugin_1.plugin; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/directives/math.js":
/*!*******************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/directives/math.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const state_1 = __webpack_require__(/*! ../state */ "./node_modules/markdown-it-myst/dist/src/state.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/markdown-it-myst/dist/src/directives/utils.js");
const math = {
    math: {
        token: 'math',
        numbered: state_1.TargetKind.equation,
        skipParsing: true,
        getArguments: () => ({ args: {}, content: '' }),
        getOptions: (data) => {
            // See https://github.com/sphinx-doc/sphinx/issues/8476
            const { name, label } = data, rest = __rest(data, ["name", "label"]);
            utils_1.unusedOptionsWarning('math', rest);
            return { name: name || label };
        },
        renderer: (args, opts, target) => {
            const { id, number } = target !== null && target !== void 0 ? target : {};
            return ['div', {
                    class: target ? ['math', 'numbered'] : 'math',
                    id,
                    number,
                }, 0];
        },
    },
};
exports.default = math;
//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/directives/options.js":
/*!**********************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/directives/options.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/markdown-it-myst/dist/src/directives/types.js");
const QUICK_PARAMETERS = /^:([a-zA-Z0-9\-_]+):(.*)$/;
function stripParams(content) {
    const data = {};
    let stopParams = false;
    const modified = content.split('\n').reduce((lines, line) => {
        const match = line.match(QUICK_PARAMETERS);
        if (stopParams || !match) {
            stopParams = true;
            return [...lines, line];
        }
        const [, key, value] = match;
        if (data[key] !== undefined) {
            console.warn(`There are multiple keys defined for ${key}: ${data[key]} and ${value.trim()}`);
        }
        data[key] = value.trim();
        return lines;
    }, []);
    return { data, modified: modified.join('\n') };
}
function stripYaml(content) {
    const data = {};
    return { data, modified: content };
}
function addDirectiveOptions(directive, parent, tokens, index, isFence = false) {
    const [open, token, close] = tokens.slice(index - 1, index + 2);
    const useToken = isFence ? parent : token;
    const { content } = useToken;
    const firstLine = content.split('\n')[0].trim();
    const isYaml = firstLine === '---';
    const isQuickParams = QUICK_PARAMETERS.test(firstLine);
    if (!isYaml && !isQuickParams) {
        const opts = directive.getOptions({});
        // eslint-disable-next-line no-param-reassign
        parent.meta = Object.assign(Object.assign({}, parent.meta), { opts });
        return;
    }
    const strip = isYaml ? stripYaml : stripParams;
    const { data, modified } = strip(useToken.content);
    const opts = directive.getOptions(data);
    // eslint-disable-next-line no-param-reassign
    parent.meta = Object.assign(Object.assign({}, parent.meta), { opts });
    useToken.content = modified;
    // Here we will stop the tags from rendering if there is no content that is not metadata
    // This stops empty paragraph tags from rendering.
    const noContent = modified.length === 0;
    if (!isFence && open && noContent)
        open.hidden = true;
    useToken.hidden = noContent;
    if (!isFence && close && noContent)
        close.hidden = true;
}
const parseOptions = (directives) => (state) => {
    var _a, _b;
    const { tokens } = state;
    let parent = false;
    let directive = false;
    let gotOptions = false;
    for (let index = 0; index < tokens.length; index += 1) {
        const token = tokens[index];
        if (token.type === types_1.DirectiveTokens.open) {
            directive = directives[(_a = token.attrGet('kind')) !== null && _a !== void 0 ? _a : ''];
            parent = token;
            gotOptions = false;
        }
        if (token.type === types_1.DirectiveTokens.close) {
            if (parent) {
                // Ensure there is metadata always defined for containers
                const meta = Object.assign({ opts: {} }, parent.meta);
                parent.meta = meta;
                token.meta = meta;
            }
            parent = false;
        }
        if (token.type === types_1.DirectiveTokens.fence) {
            addDirectiveOptions(directives[(_b = token.attrGet('kind')) !== null && _b !== void 0 ? _b : ''], token, tokens, index, true);
        }
        if (parent && !gotOptions && token.type === 'inline') {
            addDirectiveOptions(directive, parent, tokens, index);
            gotOptions = true;
        }
    }
    return true;
};
exports.default = parseOptions;
//# sourceMappingURL=options.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/directives/plugin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/directives/plugin.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.plugin = void 0;
const markdown_it_container_1 = __importDefault(__webpack_require__(/*! markdown-it-container */ "./node_modules/markdown-it-myst/node_modules/markdown-it-container/index.js"));
const options_1 = __importDefault(__webpack_require__(/*! ./options */ "./node_modules/markdown-it-myst/dist/src/directives/options.js"));
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/markdown-it-myst/dist/src/directives/types.js");
const state_1 = __webpack_require__(/*! ../state */ "./node_modules/markdown-it-myst/dist/src/state.js");
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/markdown-it-myst/dist/src/utils.js");
const DIRECTIVE_PATTERN = /^\{([a-z]*)\}\s*(.*)$/;
function getDirective(directives, kind) {
    if (!kind)
        return undefined;
    return directives[kind];
}
/**
 * Container that continues to render internally.
 *
 * For not rendering the internals (e.g. math), use `skipParsing`
 * and the directive will modify a `fence` renderer.
 *
 * @param directives The directives to use
 */
const directiveContainer = (directives) => ({
    marker: '`',
    validate(params) {
        const match = params.trim().match(DIRECTIVE_PATTERN);
        if (!match)
            return false;
        const kind = match[1];
        const directive = getDirective(directives, kind);
        return Boolean(directive) && !(directive === null || directive === void 0 ? void 0 : directive.skipParsing);
    },
    render(tokens, idx, options, env, self) {
        var _a;
        const token = tokens[idx];
        const kind = (_a = token.attrGet('kind')) !== null && _a !== void 0 ? _a : '';
        const directive = getDirective(directives, kind);
        const { args, opts, target } = token.meta;
        const htmlTemplate = directive.renderer(args, opts, target, tokens, idx, options, env, self);
        const [before, after] = utils_1.toHTML(htmlTemplate);
        return token.nesting === 1 ? before : after;
    },
});
/**
 * This overrides the `fence` when `skipParsing` is set to true on a directive.
 *
 * @param directives The directives to use
 */
const fenceRenderer = (directives) => (tokens, idx, options, env, self) => {
    var _a;
    const token = tokens[idx];
    const kind = (_a = token.attrGet('kind')) !== null && _a !== void 0 ? _a : '';
    const directive = getDirective(directives, kind);
    const { args, opts, target } = token.meta;
    const htmlTemplate = directive.renderer(args, opts, target, tokens, idx, options, env, self);
    const [before, after] = utils_1.toHTML(htmlTemplate);
    return `${before}${token.content}${after}`;
};
const setDirectiveKind = (directives) => (state) => {
    var _a, _b;
    const { tokens } = state;
    let kind = false;
    for (let index = 0; index < tokens.length; index += 1) {
        const token = tokens[index];
        if (token.type === types_1.DirectiveTokens.open) {
            const match = token.info.trim().match(DIRECTIVE_PATTERN);
            const directive = getDirective(directives, (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : '');
            if (!directive)
                throw new Error('Shoud not be able to get into here without having directive.');
            kind = directive.token;
            token.attrSet('kind', kind);
        }
        if (token.type === 'fence') {
            // Here we match the directives that `skipParsing`, and turn them into `directive_fences`
            // The options are then added as normal, the rendering is done in `fenceRenderer`
            const match = token.info.trim().match(DIRECTIVE_PATTERN);
            const directive = getDirective(directives, (_b = match === null || match === void 0 ? void 0 : match[1]) !== null && _b !== void 0 ? _b : '');
            if (directive && directive.skipParsing) {
                token.type = types_1.DirectiveTokens.fence;
                kind = directive.token;
                token.attrSet('kind', kind);
            }
        }
        if (token.type === types_1.DirectiveTokens.close) {
            // Set the kind on the closing container as well, as that will have to render the closing tags
            token.attrSet('kind', kind);
            kind = false;
        }
    }
    return true;
};
const parseArguments = (directives) => (state) => {
    var _a, _b, _c, _d;
    const { tokens } = state;
    let parent = false;
    // If there is a title on the first line when not required, bump it to the first inline
    let bumpArguments = '';
    for (let index = 0; index < tokens.length; index += 1) {
        const token = tokens[index];
        if (token.type === types_1.DirectiveTokens.open) {
            parent = token;
            const match = token.info.trim().match(DIRECTIVE_PATTERN);
            const directive = getDirective(directives, token.attrGet('kind'));
            if (!match || !directive)
                throw new Error('Shoud not be able to get into here without matching?');
            const info = match[2].trim();
            const { args, content: modified } = (_b = (_a = directive.getArguments) === null || _a === void 0 ? void 0 : _a.call(directive, info)) !== null && _b !== void 0 ? _b : {};
            token.meta = Object.assign(Object.assign({}, token.meta), { args });
            if (modified)
                bumpArguments = modified;
        }
        if (token.type === types_1.DirectiveTokens.fence) {
            const match = token.info.trim().match(DIRECTIVE_PATTERN);
            const directive = getDirective(directives, token.attrGet('kind'));
            if (!match || !directive)
                throw new Error('Shoud not be able to get into here without matching?');
            const info = match[2].trim();
            const { args, content: modified } = (_d = (_c = directive.getArguments) === null || _c === void 0 ? void 0 : _c.call(directive, info)) !== null && _d !== void 0 ? _d : {};
            token.meta = Object.assign(Object.assign({}, token.meta), { args });
            if (modified)
                token.content = modified + token.content;
        }
        if (parent && token.type === types_1.DirectiveTokens.close) {
            // TODO: https://github.com/executablebooks/MyST-Parser/issues/154
            // If the bumped title needs to be rendered - put it here somehow.
            bumpArguments = '';
            token.meta = parent.meta;
            parent = false;
        }
        if (parent && bumpArguments && token.type === 'inline') {
            token.content = `${bumpArguments} ${token.content}`;
            bumpArguments = '';
        }
    }
    return true;
};
const numbering = (directives) => (state) => {
    var _a;
    const { tokens } = state;
    for (let index = 0; index < tokens.length; index += 1) {
        const token = tokens[index];
        if (token.type === types_1.DirectiveTokens.open || token.type === types_1.DirectiveTokens.fence) {
            const directive = getDirective(directives, token.attrGet('kind'));
            const { name } = (_a = token.meta) === null || _a === void 0 ? void 0 : _a.opts;
            /* Only number things if:
             *    * the directive supports numbering
             *    * AND a name is provided
             *    * OR autoNumber for the directive is on
             */
            if ((directive === null || directive === void 0 ? void 0 : directive.numbered) && (name || (directive === null || directive === void 0 ? void 0 : directive.autoNumber))) {
                const target = state_1.newTarget(state, name, directive.numbered);
                token.meta.target = target;
            }
        }
        if (token.type === 'math_block_eqno') {
            // This is parsed using the markdownTexMath library, and the name comes on the info:
            const name = token.info;
            const target = state_1.newTarget(state, name, state_1.TargetKind.equation);
            token.meta = Object.assign(Object.assign({}, token.meta), { target });
        }
    }
    return true;
};
const plugin = (directives) => (md) => {
    const { renderer } = md;
    md.use(markdown_it_container_1.default, 'directives', directiveContainer(directives));
    md.core.ruler.after('block', 'directive_kind', setDirectiveKind(directives));
    md.core.ruler.after('directive_kind', 'parse_directive_opts', options_1.default(directives));
    md.core.ruler.after('parse_directive_opts', 'parse_directive_args', parseArguments(directives));
    md.core.ruler.after('parse_directive_args', 'numbering', numbering(directives));
    renderer.rules[types_1.DirectiveTokens.fence] = fenceRenderer(directives);
};
exports.plugin = plugin;
//# sourceMappingURL=plugin.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/directives/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/directives/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirectiveTokens = void 0;
var DirectiveTokens;
(function (DirectiveTokens) {
    DirectiveTokens["open"] = "container_directives_open";
    DirectiveTokens["close"] = "container_directives_close";
    DirectiveTokens["fence"] = "fence_directive";
    DirectiveTokens["inline"] = "inline";
})(DirectiveTokens = exports.DirectiveTokens || (exports.DirectiveTokens = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/directives/utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/directives/utils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unusedOptionsWarning = void 0;
const unusedOptionsWarning = (kind, opts) => {
    if (Object.keys(opts).length > 0) {
        console.warn(`Unknown ${kind} options`, opts);
    }
};
exports.unusedOptionsWarning = unusedOptionsWarning;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.directives = exports.roles = exports.plugins = exports.MyST = void 0;
const plugins = __importStar(__webpack_require__(/*! ./plugins */ "./node_modules/markdown-it-myst/dist/src/plugins.js"));
exports.plugins = plugins;
const roles_1 = __webpack_require__(/*! ./roles */ "./node_modules/markdown-it-myst/dist/src/roles/index.js");
Object.defineProperty(exports, "roles", ({ enumerable: true, get: function () { return roles_1.roles; } }));
const directives_1 = __webpack_require__(/*! ./directives */ "./node_modules/markdown-it-myst/dist/src/directives/index.js");
Object.defineProperty(exports, "directives", ({ enumerable: true, get: function () { return directives_1.directives; } }));
var myst_1 = __webpack_require__(/*! ./myst */ "./node_modules/markdown-it-myst/dist/src/myst.js");
Object.defineProperty(exports, "MyST", ({ enumerable: true, get: function () { return __importDefault(myst_1).default; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/math/amsmath.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/math/amsmath.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/markdown-it-myst/dist/src/math/utils.js");
// Taken from amsmath version 2.1
// http://anorien.csc.warwick.ac.uk/mirrors/CTAN/macros/latex/required/amsmath/amsldoc.pdf
const ENVIRONMENTS = [
    // 3.2 single equation with an automatically gen-erated number
    'equation',
    // 3.3 variation equation, used for equations that don’t fit on a single line
    'multline',
    // 3.5 a group of consecutive equations when there is no alignment desired among them
    'gather',
    // 3.6 Used for two or more equations when vertical alignment is desired
    'align',
    // allows the horizontal space between equationsto be explicitly specified.
    'alignat',
    // stretches the space betweenthe equation columns to the maximum possible width
    'flalign',
    // 4.1 The pmatrix, bmatrix, Bmatrix, vmatrix and Vmatrix have (respectively)
    // (),[],{},||,and ‖‖ delimiters built in.
    'matrix',
    'pmatrix',
    'bmatrix',
    'Bmatrix',
    'vmatrix',
    'Vmatrix',
    // eqnarray is another math environment, it is not part of amsmath,
    // and note that it is better to use align or equation+split instead
    'eqnarray',
];
// other "non-top-level" environments:
// 3.4 the split environment is for single equations that are too long to fit on one line
// and hence must be split into multiple lines,
// it is intended for use only inside some other displayed equation structure,
// usually an equation, align, or gather environment
// 3.7 variants gathered, aligned,and alignedat are provided
// whose total width is the actual width of the contents;
// thus they can be used as a component in a containing expression
const RE_OPEN = new RegExp(`^\\\\begin{(${ENVIRONMENTS.join('|')})([*]?)}`);
function matchEnvironment(string) {
    const matchOpen = string.match(RE_OPEN);
    if (!matchOpen)
        return null;
    const [, environment, numbered] = matchOpen;
    const end = `\\end{${environment}${numbered}}`;
    const matchClose = string.indexOf(end);
    if (matchClose === -1)
        return null;
    return { environment, numbered, endpos: matchClose + end.length };
}
function amsmathBlock(state, startLine, endLine, silent) {
    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4)
        return false;
    const begin = state.bMarks[startLine] + state.tShift[startLine];
    const outcome = matchEnvironment(state.src.slice(begin));
    if (!outcome)
        return false;
    const { environment, numbered } = outcome;
    let { endpos } = outcome;
    endpos += begin;
    let line = startLine;
    while (line < endLine) {
        if (endpos >= state.bMarks[line] && endpos <= state.eMarks[line]) {
            // line for end of block math found ...
            // eslint-disable-next-line no-param-reassign
            state.line = line + 1;
            break;
        }
        line += 1;
    }
    if (!silent) {
        const token = state.push('amsmath', 'math', 0);
        token.block = true;
        token.content = state.src.slice(begin, endpos);
        token.meta = { environment, numbered };
        token.map = [startLine, line];
    }
    return true;
}
const renderAmsmathBlock = (tokens, idx) => {
    const token = tokens[idx];
    return utils_1.renderMath(token.content, true);
};
/**
  Parses TeX math equations, without any surrounding delimiters,
  only for top-level [amsmath](https://ctan.org/pkg/amsmath) environments:
  ```latex
    \begin{gather*}
      a_1=b_1+c_1\\
      a_2=b_2+c_2-d_2+e_2
    \end{gather*}
  ```
*/
function amsmathPlugin(md) {
    const { renderer } = md;
    md.block.ruler.before('blockquote', 'amsmath', amsmathBlock, { alt: ['paragraph', 'reference', 'blockquote', 'list', 'footnote_def'] });
    renderer.rules.amsmath = renderAmsmathBlock;
}
exports.default = amsmathPlugin;
//# sourceMappingURL=amsmath.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/math/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/math/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.plugin = exports.addMathRenderers = void 0;
const markdown_it_texmath_1 = __importDefault(__webpack_require__(/*! markdown-it-texmath */ "./node_modules/markdown-it-texmath/texmath.js"));
const amsmath_1 = __importDefault(__webpack_require__(/*! ./amsmath */ "./node_modules/markdown-it-myst/dist/src/math/amsmath.js"));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/markdown-it-myst/dist/src/math/utils.js");
function addMathRenderers(md) {
    const { renderer } = md;
    renderer.rules.math_inline = (tokens, idx) => utils_1.renderMath(tokens[idx].content, false);
    // Note: this will actually create invalid HTML
    renderer.rules.math_inline_double = (tokens, idx) => utils_1.renderMath(tokens[idx].content, true);
    renderer.rules.math_block = (tokens, idx) => utils_1.renderMath(tokens[idx].content, true);
    renderer.rules.math_block_end = () => '';
    renderer.rules.math_block_eqno = (tokens, idx) => {
        var _a;
        return (utils_1.renderMath(tokens[idx].content, true, (_a = tokens[idx].meta) === null || _a === void 0 ? void 0 : _a.target));
    };
    renderer.rules.math_block_eqno_end = () => '';
}
exports.addMathRenderers = addMathRenderers;
function plugin(md) {
    md.use(markdown_it_texmath_1.default, {
        engine: { renderToString: (s) => s },
        delimiters: 'dollars',
    });
    amsmath_1.default(md);
    // Note: numbering of equations for `math_block_eqno` happens in the directives rules
    addMathRenderers(md);
}
exports.plugin = plugin;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/math/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/math/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.renderMath = void 0;
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/markdown-it-myst/dist/src/utils.js");
const renderMath = (math, block, target) => {
    const { id, number } = target !== null && target !== void 0 ? target : {};
    const [html] = utils_1.toHTML([block ? 'div' : 'span', {
            class: target ? ['math', 'numbered'] : 'math',
            id,
            number,
            children: block ? `\\[\n${math}\n\\]` : `\\(${math}\\)`,
        }], { inline: true });
    return block ? `${html}\n` : html;
};
exports.renderMath = renderMath;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/myst.js":
/*!********************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/myst.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultOptions = void 0;
const markdown_it_1 = __importDefault(__webpack_require__(/*! markdown-it */ "webpack/sharing/consume/default/markdown-it/markdown-it"));
const plugins = __importStar(__webpack_require__(/*! ./plugins */ "./node_modules/markdown-it-myst/dist/src/plugins.js"));
const directives_1 = __webpack_require__(/*! ./directives */ "./node_modules/markdown-it-myst/dist/src/directives/index.js");
const roles_1 = __webpack_require__(/*! ./roles */ "./node_modules/markdown-it-myst/dist/src/roles/index.js");
exports.defaultOptions = {
    directives: directives_1.directives,
    roles: roles_1.roles,
    math: true,
    markdownit: { html: false },
};
function MyST(opts = exports.defaultOptions) {
    const tokenizer = markdown_it_1.default('commonmark', opts.markdownit);
    if (opts.math)
        tokenizer.use(plugins.math);
    tokenizer.use(plugins.blocks);
    tokenizer.use(plugins.directives(directives_1.directives));
    tokenizer.use(plugins.roles(roles_1.roles));
    return tokenizer;
}
exports.default = MyST;
//# sourceMappingURL=myst.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/plugins.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/plugins.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.directives = exports.roles = exports.math = exports.blocks = void 0;
var blocks_1 = __webpack_require__(/*! ./blocks */ "./node_modules/markdown-it-myst/dist/src/blocks.js");
Object.defineProperty(exports, "blocks", ({ enumerable: true, get: function () { return blocks_1.plugin; } }));
var math_1 = __webpack_require__(/*! ./math */ "./node_modules/markdown-it-myst/dist/src/math/index.js");
Object.defineProperty(exports, "math", ({ enumerable: true, get: function () { return math_1.plugin; } }));
var roles_1 = __webpack_require__(/*! ./roles */ "./node_modules/markdown-it-myst/dist/src/roles/index.js");
Object.defineProperty(exports, "roles", ({ enumerable: true, get: function () { return roles_1.plugin; } }));
var directives_1 = __webpack_require__(/*! ./directives */ "./node_modules/markdown-it-myst/dist/src/directives/index.js");
Object.defineProperty(exports, "directives", ({ enumerable: true, get: function () { return directives_1.plugin; } }));
//# sourceMappingURL=plugins.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/roles/generic.js":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/roles/generic.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/markdown-it-myst/dist/src/utils.js");
const roles = {
    myst_role: {
        token: 'myst_role',
        renderer: (tokens, idx) => {
            var _a, _b;
            const token = tokens[idx];
            const name = (_b = (_a = token.meta) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'unknown';
            const [html] = utils_1.toHTML([
                'code',
                { class: 'myst-role', children: `{${name}}\`${token.content}\`` },
            ], { inline: true });
            return html;
        },
    },
};
exports.default = roles;
//# sourceMappingURL=generic.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/roles/html.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/roles/html.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/markdown-it-myst/dist/src/utils.js");
const ABBR_PATTERN = /^(.+?)\(([^()]+)\)$/; // e.g. 'CSS (Cascading Style Sheets)'
const roles = {
    abbr: {
        token: 'abbr',
        getAttrs(content) {
            const match = ABBR_PATTERN.exec(content);
            if (match == null)
                return { attrs: { title: null }, content };
            const [, modified, title] = match;
            return { attrs: { title: title.trim() }, content: modified.trim() };
        },
        renderer: (tokens, idx) => {
            const token = tokens[idx];
            const [html] = utils_1.toHTML(['abbr', { title: token.attrGet('title'), children: token.content }], { inline: true });
            return html;
        },
    },
    sub: {
        token: 'sub',
        renderer: (tokens, idx) => {
            const [html] = utils_1.toHTML(['sub', { children: tokens[idx].content }], { inline: true });
            return html;
        },
    },
    sup: {
        token: 'sup',
        renderer: (tokens, idx) => {
            const [html] = utils_1.toHTML(['sup', { children: tokens[idx].content }], { inline: true });
            return html;
        },
    },
};
exports.default = roles;
//# sourceMappingURL=html.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/roles/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/roles/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.plugin = exports.roles = void 0;
const html_1 = __importDefault(__webpack_require__(/*! ./html */ "./node_modules/markdown-it-myst/dist/src/roles/html.js"));
const math_1 = __importDefault(__webpack_require__(/*! ./math */ "./node_modules/markdown-it-myst/dist/src/roles/math.js"));
const references_1 = __importDefault(__webpack_require__(/*! ./references */ "./node_modules/markdown-it-myst/dist/src/roles/references.js"));
const generic_1 = __importDefault(__webpack_require__(/*! ./generic */ "./node_modules/markdown-it-myst/dist/src/roles/generic.js"));
exports.roles = Object.assign(Object.assign(Object.assign(Object.assign({}, html_1.default), math_1.default), references_1.default), generic_1.default);
var plugin_1 = __webpack_require__(/*! ./plugin */ "./node_modules/markdown-it-myst/dist/src/roles/plugin.js");
Object.defineProperty(exports, "plugin", ({ enumerable: true, get: function () { return plugin_1.plugin; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/roles/math.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/roles/math.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __webpack_require__(/*! ../math/utils */ "./node_modules/markdown-it-myst/dist/src/math/utils.js");
const roles = {
    math: {
        token: 'math_inline',
        renderer: (tokens, idx) => utils_1.renderMath(tokens[idx].content, false),
    },
};
exports.default = roles;
//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/roles/plugin.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/roles/plugin.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.plugin = void 0;
const generic_1 = __importDefault(__webpack_require__(/*! ./generic */ "./node_modules/markdown-it-myst/dist/src/roles/generic.js"));
// Ported from https://github.com/executablebooks/markdown-it-py/blob/master/markdown_it/extensions/myst_role/index.py
// MIT License: https://github.com/executablebooks/markdown-it-py/blob/master/LICENSE
// e.g. {role}`text`
let x;
try {
    x = new RegExp('^\\{([a-zA-Z_\\-+:]{1,36})\\}(`+)(?!`)(.+?)(?<!`)\\2(?!`)');
}
catch (error) {
    // Safari does not support negative look-behinds
    // This is a slightly down-graded, as it does not require a space.
    x = /^\{([a-zA-Z_\-+:]{1,36})\}(`+)(?!`)(.+?)\2(?!`)/;
}
const ROLE_PATTERN = x;
const getRoleAttrs = (roles) => (name, content) => {
    var _a, _b;
    const roleF = (_a = roles[name]) !== null && _a !== void 0 ? _a : generic_1.default.myst_role;
    if (roleF.getAttrs) {
        const { attrs, content: modified } = roleF.getAttrs(content);
        return { token: roleF.token, attrs: attrs !== null && attrs !== void 0 ? attrs : {}, content: modified !== null && modified !== void 0 ? modified : content };
    }
    return { token: roleF.token, attrs: (_b = roleF.attrs) !== null && _b !== void 0 ? _b : {}, content };
};
const addRenderers = (roles) => (md) => {
    const { renderer } = md;
    Object.entries(roles).forEach(([, { token, renderer: tokenRenderer }]) => {
        // Early return if the role is already defined
        // e.g. math_inline might be better handled by another plugin
        if (md.renderer.rules[token])
            return;
        renderer.rules[token] = tokenRenderer;
    });
};
const mystRole = (roles) => (state, silent) => {
    // Check if the role is escaped
    if (state.src.charCodeAt(state.pos - 1) === 0x5C) { /* \ */
        // TODO: this could be improved in the case of edge case '\\{'
        return false;
    }
    const match = ROLE_PATTERN.exec(state.src.slice(state.pos));
    if (match == null)
        return false;
    const [str, name, , content] = match;
    // eslint-disable-next-line no-param-reassign
    state.pos += str.length;
    if (!silent) {
        const role = getRoleAttrs(roles)(name, content);
        const token = state.push(role.token, '', 0);
        Object.entries(role.attrs).map(([k, v]) => token.attrSet(k, v));
        token.meta = { name };
        token.content = role.content;
    }
    return true;
};
const plugin = (roles) => (md) => {
    md.inline.ruler.before('backticks', 'myst_role', mystRole(roles));
    addRenderers(roles)(md);
};
exports.plugin = plugin;
//# sourceMappingURL=plugin.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/roles/references.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/roles/references.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const state_1 = __webpack_require__(/*! ../state */ "./node_modules/markdown-it-myst/dist/src/state.js");
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/markdown-it-myst/dist/src/utils.js");
const REF_PATTERN = /^(.+?)<([^<>]+)>$/; // e.g. 'Labeled Reference <ref>'
const renderReferenceError = (ref) => {
    const [html] = utils_1.toHTML([
        'span', {
            class: 'error',
            title: `The reference '${ref}' was not found.`,
            children: `Reference '${ref}' not found.`,
        },
    ], { inline: true });
    return html;
};
/**
 * Renders a reference as an anchor link.
 */
const renderReference = (opts) => (tokens, idx, options, env) => {
    var _a;
    const token = tokens[idx];
    const ref = (_a = token.attrGet('ref')) !== null && _a !== void 0 ? _a : '';
    const target = env.targets[ref];
    if (!target || (opts.kind && (target === null || target === void 0 ? void 0 : target.kind) !== opts.kind))
        return renderReferenceError(ref);
    const { id, title, defaultReference, number, } = target;
    let text = token.content || title || defaultReference;
    if (opts.numbered) {
        // See https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html#role-numref
        text = text.replace(/%s/g, String(number)).replace(/\{number\}/g, String(number));
    }
    if (opts.brackets) {
        text = `${token.content}(${number})`;
    }
    const [html] = utils_1.toHTML([
        'a', {
            href: `#${id}`,
            title: title || defaultReference,
            children: text,
        },
    ], { inline: true });
    return html;
};
const getReferenceAttrs = (content) => {
    const match = REF_PATTERN.exec(content);
    if (match == null)
        return { attrs: { ref: content }, content: '' };
    const [, modified, ref] = match;
    return { attrs: { ref: ref.trim() }, content: modified.trim() };
};
const roles = {
    ref: {
        token: 'ref',
        getAttrs: getReferenceAttrs,
        renderer: renderReference({ numbered: false, brackets: false }),
    },
    numref: {
        token: 'numref',
        getAttrs: getReferenceAttrs,
        renderer: renderReference({ numbered: true, brackets: false }),
    },
    eq: {
        token: 'eq',
        getAttrs: getReferenceAttrs,
        renderer: renderReference({ numbered: true, brackets: true, kind: state_1.TargetKind.equation }),
    },
};
exports.default = roles;
//# sourceMappingURL=references.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/state.js":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/state.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-param-reassign */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.newTarget = exports.getStateEnv = exports.TargetKind = void 0;
const utils_1 = __webpack_require__(/*! markdown-it/lib/common/utils */ "./node_modules/markdown-it/lib/common/utils.js");
var TargetKind;
(function (TargetKind) {
    TargetKind["ref"] = "ref";
    TargetKind["equation"] = "eq";
    TargetKind["figure"] = "fig";
    TargetKind["table"] = "table";
    TargetKind["code"] = "code";
})(TargetKind = exports.TargetKind || (exports.TargetKind = {}));
const RefFormatter = {
    ref(id) { return `[${id}]`; },
    eq(id, num) { return `Eq ${num}`; },
    fig(id, num) { return `Fig ${num}`; },
    table(id, num) { return `Table ${num}`; },
    code(id, num) { return `Code ${num}`; },
};
function getStateEnv(state) {
    var _a;
    const env = (_a = state.env) !== null && _a !== void 0 ? _a : {};
    if (!env.targets)
        env.targets = {};
    if (!env.numbering) {
        env.numbering = {
            eq: 0,
            fig: 0,
            table: 0,
            code: 0,
        };
    }
    if (!state.env)
        state.env = env;
    return env;
}
exports.getStateEnv = getStateEnv;
/** Get the next number for an equation, figure, code or table
 *
 * Can input `{ numbering: { equation: 100 } }` to start counting at a different numebr.
 *
 * @param state MarkdownIt state that will be modified
 */
function nextNumber(state, kind) {
    if (kind === TargetKind.ref)
        throw new Error('Targets are not numbered?');
    const env = getStateEnv(state);
    env.numbering[kind] += 1;
    return env.numbering[kind];
}
/** Create a new internal target.
 *
 * @param state MarkdownIt state that will be modified
 * @param name The reference name that will be used for the target. Note some directives use label.
 * @param kind The target kind: "ref", "equation", "code", "table" or "figure"
 */
function newTarget(state, name, kind) {
    const env = getStateEnv(state);
    const number = kind === TargetKind.ref ? undefined : nextNumber(state, kind);
    // TODO: not sure about this - if name is not provided, then you get `fig-1` etc.
    const useName = name ? utils_1.escapeHtml(name) : `${kind}-${String(number)}`;
    const id = name ? `${kind}-${utils_1.escapeHtml(useName)}` : useName;
    const target = {
        id,
        name: useName,
        defaultReference: RefFormatter[kind](id, number),
        kind,
        number,
    };
    env.targets[useName] = target;
    return target;
}
exports.newTarget = newTarget;
//# sourceMappingURL=state.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/dist/src/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it-myst/dist/src/utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toHTML = exports.formatTag = void 0;
const utils_1 = __webpack_require__(/*! markdown-it/lib/common/utils */ "./node_modules/markdown-it/lib/common/utils.js");
const HTML_EMPTY_ELEMENTS = new Set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);
const formatAttr = (key, value) => {
    let v;
    if (value == null)
        return null;
    if (Array.isArray(value)) {
        v = value.join(' ');
    }
    else if (typeof value === 'number') {
        v = String(value);
    }
    else if (typeof value === 'boolean') {
        if (!value)
            return null;
        v = '';
    }
    else {
        v = value;
    }
    return `${key}="${utils_1.escapeHtml(v)}"`;
};
function formatTag(tag, attributes, inline) {
    const { children } = attributes, rest = __rest(attributes, ["children"]);
    const join = inline ? '' : '\n';
    const attrs = Object.entries(rest)
        .filter(([, value]) => value != null && value !== false)
        .map(([key, value]) => formatAttr(key, value))
        .filter((value) => value != null)
        .join(' ');
    const html = `<${utils_1.escapeHtml(tag)}${attrs ? ` ${attrs}` : ''}>`;
    if (children)
        return `${html}${join}${utils_1.escapeHtml(String(children))}`;
    return html;
}
exports.formatTag = formatTag;
function toHTMLRecurse(template, inline) {
    // Convert to an internal type which is actually an array
    const T = template;
    // Cannot have more than one hole in the template
    const atMostOneHole = T.flat(Infinity).filter((v) => v === 0).length <= 1;
    if (!atMostOneHole)
        throw new Error('There cannot be more than one hole in the template.');
    // Grab the tag and attributes if they exist!
    const tag = T[0];
    const hasAttrs = !Array.isArray(T === null || T === void 0 ? void 0 : T[1]) && typeof (T === null || T === void 0 ? void 0 : T[1]) === 'object';
    const attrs = hasAttrs ? T[1] : {};
    // These are the tag arrays before and after the hole.
    const before = [];
    const after = [];
    before.push(formatTag(tag, attrs, inline));
    let foundHole = false;
    T.slice(hasAttrs ? 2 : 1).forEach((value) => {
        const v = value;
        if (v === 0) {
            foundHole = true;
            return;
        }
        // Recurse, if a hole is found then split the return
        const [b, a] = toHTMLRecurse(v, inline);
        before.push(b);
        if (a) {
            foundHole = true;
            after.push(a);
        }
    });
    const join = inline ? '' : '\n';
    const closingTag = HTML_EMPTY_ELEMENTS.has(tag) ? '' : `</${tag}>`;
    if (!foundHole) {
        if (closingTag)
            before.push(closingTag);
        return [before.join(join), null];
    }
    if (closingTag)
        after.push(closingTag);
    return [before.join(join), after.join(join)];
}
/**
 * A helper function to create valid HTML with a "hole" (represented by zero) for content.
 *
 * The content is escaped and null/undefined attributes are not included.
 *
 * **A simple wrapper tag:**
 * ```
 * const attr = 'hello';
 * const html = toHTML(['tag', {attr}, 0]);
 * console.log(html);
 * > ['<tag attr="hello">', '</tag>']
 * ```
 *
 * **A nested wrapper tag:**
 * ```
 * const html = toHTML([
 *  'tag', {attr},
 *  ['img', {src}],
 *  ['caption', 0],
 * ]);
 * console.log(html);
 * > ['<tag attr="x"><img src="src"><caption>', '</caption></tag>']
 * ```
 *
 * You can include `children` in the `attrs` and that adds inline content for a tag.
 *
 * You can also send in a list of strings for `attrs`, which are joined with a space (`' '`).
 *
 * Types are based on prosemirror-model.
 *
 * @param spec The spec for the dom model.
 * @param opts Options dict, `inline` creates HTML that is on a single line.
 */
function toHTML(template, opts = { inline: false }) {
    const [before, after] = toHTMLRecurse(template, opts.inline);
    const join = opts.inline ? '' : '\n';
    return [`${before}${join}`, after ? `${after}${join}` : null];
}
exports.toHTML = toHTML;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/markdown-it-myst/node_modules/markdown-it-container/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/markdown-it-myst/node_modules/markdown-it-container/index.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
// Process block-level custom containers
//



module.exports = function container_plugin(md, name, options) {

  // Second param may be useful if you decide
  // to increase minimal allowed marker length
  function validateDefault(params/*, markup*/) {
    return params.trim().split(' ', 2)[0] === name;
  }

  function renderDefault(tokens, idx, _options, env, slf) {

    // add a class to the opening tag
    if (tokens[idx].nesting === 1) {
      tokens[idx].attrJoin('class', name);
    }

    return slf.renderToken(tokens, idx, _options, env, slf);
  }

  options = options || {};

  var min_markers = 3,
      marker_str  = options.marker || ':',
      marker_char = marker_str.charCodeAt(0),
      marker_len  = marker_str.length,
      validate    = options.validate || validateDefault,
      render      = options.render || renderDefault;

  function container(state, startLine, endLine, silent) {
    var pos, nextLine, marker_count, markup, params, token,
        old_parent, old_line_max,
        auto_closed = false,
        start = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine];

    // Check out the first character quickly,
    // this should filter out most of non-containers
    //
    if (marker_char !== state.src.charCodeAt(start)) { return false; }

    // Check out the rest of the marker string
    //
    for (pos = start + 1; pos <= max; pos++) {
      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {
        break;
      }
    }

    marker_count = Math.floor((pos - start) / marker_len);
    if (marker_count < min_markers) { return false; }
    pos -= (pos - start) % marker_len;

    markup = state.src.slice(start, pos);
    params = state.src.slice(pos, max);
    if (!validate(params, markup)) { return false; }

    // Since start is found, we can report success here in validation mode
    //
    if (silent) { return true; }

    // Search for the end of the block
    //
    nextLine = startLine;

    for (;;) {
      nextLine++;
      if (nextLine >= endLine) {
        // unclosed block should be autoclosed by end of document.
        // also block seems to be autoclosed by end of parent
        break;
      }

      start = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (start < max && state.sCount[nextLine] < state.blkIndent) {
        // non-empty line with negative indent should stop the list:
        // - ```
        //  test
        break;
      }

      if (marker_char !== state.src.charCodeAt(start)) { continue; }

      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        // closing fence should be indented less than 4 spaces
        continue;
      }

      for (pos = start + 1; pos <= max; pos++) {
        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {
          break;
        }
      }

      // closing code fence must be at least as long as the opening one
      if (Math.floor((pos - start) / marker_len) < marker_count) { continue; }

      // make sure tail has spaces only
      pos -= (pos - start) % marker_len;
      pos = state.skipSpaces(pos);

      if (pos < max) { continue; }

      // found!
      auto_closed = true;
      break;
    }

    old_parent = state.parentType;
    old_line_max = state.lineMax;
    state.parentType = 'container';

    // this will prevent lazy continuations from ever going past our end marker
    state.lineMax = nextLine;

    token        = state.push('container_' + name + '_open', 'div', 1);
    token.markup = markup;
    token.block  = true;
    token.info   = params;
    token.map    = [ startLine, nextLine ];

    state.md.block.tokenize(state, startLine + 1, nextLine);

    token        = state.push('container_' + name + '_close', 'div', -1);
    token.markup = state.src.slice(start, pos);
    token.block  = true;

    state.parentType = old_parent;
    state.lineMax = old_line_max;
    state.line = nextLine + (auto_closed ? 1 : 0);

    return true;
  }

  md.block.ruler.before('fence', 'container_' + name, container, {
    alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]
  });
  md.renderer.rules['container_' + name + '_open'] = render;
  md.renderer.rules['container_' + name + '_close'] = render;
};


/***/ }),

/***/ "./node_modules/markdown-it-texmath/texmath.js":
/*!*****************************************************!*\
  !*** ./node_modules/markdown-it-texmath/texmath.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Stefan Goessner - 2017-20. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function texmath(md, options) {
    const delimiters = options && options.delimiters || 'dollars';
    const katexOptions = options && options.katexOptions || { throwOnError: false };
    katexOptions.macros = options && options.macros || katexOptions.macros;  // ensure backwards compatibility

    if (!texmath.katex) { // else ... depricated `use` method was used ...
        if (options && typeof options.engine === 'object') {
            texmath.katex = options.engine;
        }
        else if (true)
            texmath.katex = __webpack_require__(/*! katex */ "webpack/sharing/consume/default/katex/katex");
        else  // artifical error object.
            {}
    }

    if (delimiters in texmath.rules) {
        for (const rule of texmath.rules[delimiters].inline) {
            md.inline.ruler.before('escape', rule.name, texmath.inline(rule));  // ! important
            md.renderer.rules[rule.name] = (tokens, idx) => rule.tmpl.replace(/\$1/,texmath.render(tokens[idx].content,!!rule.displayMode,katexOptions));
        }

        for (const rule of texmath.rules[delimiters].block) {
            md.block.ruler.before('fence', rule.name, texmath.block(rule));  // ! important for ```math delimiters
            md.renderer.rules[rule.name] = (tokens, idx) => rule.tmpl.replace(/\$2/,tokens[idx].info)  // equation number .. ?
                                                                     .replace(/\$1/,texmath.render(tokens[idx].content,true,katexOptions));
        }
    }
}

// texmath.inline = (rule) => dollar;  // just for debugging/testing ..

texmath.inline = (rule) => 
    function(state, silent) {
        const pos = state.pos;
        const str = state.src;
        const pre = str.startsWith(rule.tag, rule.rex.lastIndex = pos) && (!rule.pre || rule.pre(str, pos));  // valid pre-condition ...
        const match = pre && rule.rex.exec(str);
        const res = !!match && pos < rule.rex.lastIndex && (!rule.post || rule.post(str, rule.rex.lastIndex - 1));

        if (res) { 
            if (!silent) {
                const token = state.push(rule.name, 'math', 0);
                token.content = match[1];
                token.markup = rule.tag;
            }
            state.pos = rule.rex.lastIndex;
        }
        return res;
    }

texmath.block = (rule) => 
    function block(state, begLine, endLine, silent) {
        const pos = state.bMarks[begLine] + state.tShift[begLine];
        const str = state.src;
        const pre = str.startsWith(rule.tag, rule.rex.lastIndex = pos) && (!rule.pre || rule.pre(str, pos));  // valid pre-condition ....
        const match = pre && rule.rex.exec(str);
        const res = !!match
                 && pos < rule.rex.lastIndex 
                 && (!rule.post || rule.post(str, rule.rex.lastIndex - 1));

        if (res && !silent) {    // match and valid post-condition ...
            const endpos = rule.rex.lastIndex - 1;
            let curline;

            for (curline = begLine; curline < endLine; curline++)
                if (endpos >= state.bMarks[curline] + state.tShift[curline] && endpos <= state.eMarks[curline]) // line for end of block math found ...
                    break;

            // "this will prevent lazy continuations from ever going past our end marker"
            // s. https://github.com/markdown-it/markdown-it-container/blob/master/index.js
            const lineMax = state.lineMax;
            const parentType = state.parentType;
            state.lineMax = curline;
            state.parentType = 'math';

            if (parentType === 'blockquote') // remove all leading '>' inside multiline formula
                match[1] = match[1].replace(/(\n*?^(?:\s*>)+)/gm,'');
            // begin token
            let token = state.push(rule.name, 'math', 1);  // 'math_block'
            token.block = true;
            token.markup = rule.tag;
            token.content = match[1];
            token.info = match[match.length-1];    // eq.no
            token.map = [ begLine, curline ];
            // end token
            token = state.push(rule.name+'_end', 'math', -1);
            token.block  = true;
            token.markup = rule.tag;

            state.parentType = parentType;
            state.lineMax = lineMax;
            state.line = curline+1;
        }
        return res;
    }

texmath.render = function(tex,displayMode,options) {
    options.displayMode = displayMode;
    let res;
    try {
        res = texmath.katex.renderToString(tex, options);
    }
    catch(err) {
        res = tex+": "+err.message.replace("<","&lt;");
    }
    return res;
}

// ! deprecated ... use options !
texmath.use = function(katex) {  // math renderer used ...
    texmath.katex = katex;       // ... katex solely at current ...
    return texmath;
}

/*
function dollar(state, silent) {
  var start, max, marker, matchStart, matchEnd, token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x24) { return false; }  // $

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x24) { pos++; }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('$', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x24) { matchEnd++; }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token         = state.push('math_inline', 'math', 0);
        token.markup  = marker;
        token.content = state.src.slice(pos, matchStart)
                                 .replace(/[ \n]+/g, ' ')
                                 .trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) { state.pending += marker; }
  state.pos += marker.length;
  return true;
};
*/

// used for enable/disable math rendering by `markdown-it`
texmath.inlineRuleNames = ['math_inline','math_inline_double'];
texmath.blockRuleNames  = ['math_block','math_block_eqno'];

texmath.$_pre = (str,beg) => {
    const prv = beg > 0 ? str[beg-1].charCodeAt(0) : false;
    return !prv || prv !== 0x5c                // no backslash,
                && (prv < 0x30 || prv > 0x39); // no decimal digit .. before opening '$'
}
texmath.$_post = (str,end) => {
    const nxt = str[end+1] && str[end+1].charCodeAt(0);
    return !nxt || nxt < 0x30 || nxt > 0x39;   // no decimal digit .. after closing '$'
}

texmath.rules = {
    brackets: {
        inline: [ 
            {   name: 'math_inline',
                rex: /\\\((.+?)\\\)/gy,
                tmpl: '<eq>$1</eq>',
                tag: '\\('
            }
        ],
        block: [
            {   name: 'math_block_eqno',
                rex: /\\\[(((?!\\\]|\\\[)[\s\S])+?)\\\]\s*?\(([^)$\r\n]+?)\)/gmy,
                tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
                tag: '\\['
            },
            {   name: 'math_block',
                rex: /\\\[([\s\S]+?)\\\]/gmy,
                tmpl: '<section><eqn>$1</eqn></section>',
                tag: '\\['
            }
        ]
    },
    gitlab: {
        inline: [ 
            {   name: 'math_inline',
                rex: /\$`(.+?)`\$/gy,
                tmpl: '<eq>$1</eq>',
                tag: '$`'
            }
        ],
        block: [
            {   name: 'math_block_eqno',
                rex: /`{3}math\s*([^`]+?)\s*?`{3}\s*\(([^)\r\n]+?)\)/gm,
                tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
                tag: '```math'
            },
            {   name: 'math_block',
                rex: /`{3}math\s*([^`]*?)\s*`{3}/gm,
                tmpl: '<section><eqn>$1</eqn></section>',
                tag: '```math'
            }
        ]
    },
    julia: {
        inline: [ 
            {   name: 'math_inline', 
                rex: /`{2}([^`]+?)`{2}/gy,
                tmpl: '<eq>$1</eq>',
                tag: '``'
            },
            {   name: 'math_inline',
                rex: /\$((?:\S?)|(?:\S.*?\S))\$/gy,
                tmpl: '<eq>$1</eq>',
                tag: '$',
                pre: texmath.$_pre,
                post: texmath.$_post
            }
        ],
        block: [
            {   name: 'math_block_eqno',
                rex: /`{3}math\s+?([^`]+?)\s+?`{3}\s*?\(([^)$\r\n]+?)\)/gmy,
                tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
                tag: '```math'
            },
            {   name: 'math_block',
                rex: /`{3}math\s+?([^`]+?)\s+?`{3}/gmy,
                tmpl: '<section><eqn>$1</eqn></section>',
                tag: '```math'
            }
        ]
    },
    kramdown: {
        inline: [ 
            {   name: 'math_inline', 
                rex: /\${2}(.+?)\${2}/gy,
                tmpl: '<eq>$1</eq>',
                tag: '$$'
            }
        ],
        block: [
            {   name: 'math_block_eqno',
                rex: /\${2}([^$]+?)\${2}\s*?\(([^)\s]+?)\)/gmy,
                tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
                tag: '$$'
            },
            {   name: 'math_block',
                rex: /\${2}([^$]+?)\${2}/gmy,
                tmpl: '<section><eqn>$1</eqn></section>',
                tag: '$$'
            }
        ]
    },
    dollars: {
        inline: [
            {   name: 'math_inline_double',
                rex: /\${2}((?:\S)|(?:\S.*?\S))\${2}/gy,
                tmpl: '<section><eqn>$1</eqn></section>',
                tag: '$$',
                displayMode: true,
                pre: texmath.$_pre,
                post: texmath.$_post
            },
            {   name: 'math_inline',
                rex: /\$((?:\S)|(?:\S.*?\S))\$/gy,
                tmpl: '<eq>$1</eq>',
                tag: '$',
                pre: texmath.$_pre,
                post: texmath.$_post
            }
        ],
        block: [
            {   name: 'math_block_eqno',
                rex: /\${2}([^$]+?)\${2}\s*?\(([^)\s]+?)\)/gmy,
                tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
                tag: '$$'
            },
            {   name: 'math_block',
                rex: /\${2}([^$]+?)\${2}/gmy,
                tmpl: '<section><eqn>$1</eqn></section>',
                tag: '$$'
            }
        ]
    }
};

if ( true && module.exports)
   module.exports = texmath;

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_markdown-it-myst_dist_src_index_js.1dfc8d9dfce919fbe4b4.js.map